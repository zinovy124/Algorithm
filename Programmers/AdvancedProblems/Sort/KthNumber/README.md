# 프로그래머스 K번째 수

## 문제 설명
배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.

예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면

array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다.
1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다.
2에서 나온 배열의 3번째 숫자는 5입니다.
배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요.

### 제한사항
array의 길이는 1 이상 100 이하입니다.
array의 각 원소는 1 이상 100 이하입니다.
commands의 길이는 1 이상 50 이하입니다.
commands의 각 원소는 길이가 3입니다.
### 입출력 예
| array                 | commands                          | return    |
| --------------------- | --------------------------------- | --------- |
| [1, 5, 2, 6, 3, 7, 4] | \[[2, 5, 3], [4, 4, 1], [1, 7, 3]] | [5, 6, 3] |
### 입출력 예 설명
[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.
[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.
[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다.

## 문제 풀이 과정
정렬 카테고리 문제이므로 정렬 함수를 사용하지 않고 정렬을 직접 구현해보았습니다.   
일반적인 상황에서 비교 기반 정렬의 시간 복잡도는 $O(N \log N)$을 넘을 수 없습니다. 즉, 비교 기반 정렬에서 가장 좋은 시간 복잡도가 $O(N \log N)$인 것입니다. 가장 흔히 사용되는 비교 기반 정렬은 퀵정렬, 합병정렬, 힙정렬 정도가 있습니다.   
하지만 본 문제에서는 정렬할 데이터가 1부터 100까지로 제한되어 있기 때문에, 계수 정렬(Counting Sort)를 사용해보았습니다.
### 계수 정렬
각 숫자가 배열에 몇 번 나타나는지를 세어 그 횟수를 바탕으로 전체 배열을 정렬하는 방식입니다. 계수 정렬은 데이터의 크기가 제한적일 경우, 매우 빠른 실행 시간을 보이고, $N$을 배열의 길이, $K$를 데이터의 범위(이 문제에서는 100)로 둘 때, 시간 복잡도가 $O(N + K)$입니다. 이 문제의 경우 특정 인덱스부터 다른 인덱스까지를 계수 정렬 후 $K$번째 값을 찾아 반환하면 됩니다.
### 문제 적용 과정
1. 주어진 배열의 $i$번째부터 $j$번째까지의 부분을 자릅니다.
2. 1부터 100까지의 각 숫자 출현 횟수를 세기 위한 카운트 배열을 준비합니다.
3. 잘라낸 배열을 순회하면서, 각 숫자의 출현 횟수를 카운트 배열에 기록합니다.
4. 카운트 배열을 순회하면서, 각 숫자의 출현 횟수만큼 숫자를 순서대로 배열에 추가합니다.
5. 정렬된 배열에서 $K$번째 값을 반환합니다.
#### 4번 추가 설명
**입력 배열 준비**: 정렬하고자 하는 데이터가 담긴 배열이 주어집니다. 예를 들어, [3, 1, 2, 3, 1]과 같은 배열이 있을 수 있습니다.

**카운트 배열 생성**: 데이터의 범위에 따른 크기를 가진 카운트 배열을 생성하고, 모든 값을 0으로 초기화합니다. 예를 들어, 데이터가 1부터 3까지의 정수라면, 크기가 3인 카운트 배열 [0, 0, 0]을 만듭니다.

**데이터 출현 횟수 세기**: 입력 배열을 순회하면서 각 데이터가 몇 번 출현하는지 카운트 배열에 기록합니다. 예를 들어, 위의 배열에서 1은 2번, 2는 1번, 3은 2번 출현하므로, 카운트 배열은 [2, 1, 2]가 됩니다.

**카운트 배열을 이용한 정렬**: 이제 카운트 배열을 사용하여 정렬된 배열을 생성합니다. 카운트 배열의 각 인덱스는 실제 데이터의 값에 해당하며, 각 인덱스의 값은 해당 데이터가 출현하는 횟수를 나타냅니다. 따라서 카운트 배열을 순회하면서 각 인덱스(데이터 값)를 해당 인덱스의 값(출현 횟수)만큼 정렬된 배열에 추가합니다.

**정리**
카운트 배열: [2, 1, 2]
정렬 과정:
1의 출현 횟수는 2번이므로, 정렬된 배열에 1을 두 번 추가합니다: [1, 1]
2의 출현 횟수는 1번이므로, 정렬된 배열에 2를 한 번 추가합니다: [1, 1, 2]
3의 출현 횟수는 2번이므로, 정렬된 배열에 3을 두 번 추가합니다: [1, 1, 2, 3, 3]
결과적으로 정렬된 배열은 [1, 1, 2, 3, 3]이 됩니다.

## 코드
```cpp
#include <string>
#include <vector>
#include <iostream>

using namespace std;

vector<int> countingSort(vector<int> arr) {
    vector<int> count(101, 0);
    vector<int> result;
    for (int i = 0; i < arr.size(); i++) {
        count[arr[i]]++;
    }
    for (int i = 1; i <= 100; i++) {
        for (int j = 0; j < count[i]; j++) {
            result.push_back(i);
        }
    }

    return result;
}

vector<int> solution(vector<int> array, vector<vector<int> > commands) {
    vector<int> answer;
    for (int i = 0; i < commands.size(); i++) {
        int k = commands[i][0] - 1;
        int l = commands[i][1] - 1;
        int m = commands[i][2] - 1;
        vector<int> temp(array.begin() + k, array.begin() + l + 1);
        temp = countingSort(temp);
        answer.push_back(temp[m]);
    }

    return answer;
}

int main(void) {
    vector<int> arr = {1, 5, 2, 6, 3, 7, 4};
    vector<vector<int>> comm = {{2, 5, 3}, {4, 4, 1}, {1, 7, 3}};

    vector<int> answer = solution(arr, comm);

    for (int i = 0; i < answer.size(); i++) {
        cout << answer[i] << " ";
    }
    cout << endl;
    
    return 0;
}
```

### 코드 설명
#### countingSort
`countingSort`는 계수 정렬을 수행하는 함수로, `count[arr[i]]++`이 계수 정렬 알고리즘의 핵심 부분이 되겠습니다.   
`arr`은 0부터 시작하고 `count`도 0부터 시작하지만 자연수를 표현하기 위해 `count`의 크기가 101임에 주의하고 for문을 작성합니다.   
`arr.size()`는 `arr`의 크기를 리턴하므로 범위에 포함하지 않게 하여 정상적으로 인덱스를 참조할 수 있게 합니다.   
`count`배열은 이제 각 수가 몇 번 `arr`에 등장했는지를 담고 있습니다.   
예를 들어 `count[3]`이 4라면 `arr`에 3이라는 숫자가 네 번 등장했다는 뜻입니다.   
이제 이를 결과 벡터 `result`에 담습니다.
`count[i]`는 i번째 수가 `arr`에 몇 번 나타났나를 나타내는데, 예를 들어
- `i`가 1일 때 `count[i]`가 3 : 1을 세 번 result에 담음
- `i`가 2일 때 `count[i]`가 1 : 2를 한 번 result에 담음
- `i`가 3일 때 `count[i]`가 4 : 3을 네 번 result에 담음
그러면 `[1, 1, 1, 2, 3, 3, 3, 3]`이라는 정렬된 배열이 나오게 됩니다. 그 벡터를 리턴합니다.

#### solution
`solution` 함수는 countingSort를 호출하기 위해 파라미터를 설정하는 함수입니다.   
입력 중 commands 배열은 한 행이 하나의 테스트 케이스이며, 행의 크기는 3으로 고정됩니다.   
각 행의 첫 번째 원소가 `i`이며, 두 번째 원소가 `j`이고 이는 입력한 배열을 자를 범위를 설정하는 파라미터입니다.   
그리고 세 번째 원소인 `k`가, 자른 배열의 `k`번째 원소를 고르는 파라미터입니다.   
for문의 i와 변수명이 겹치므로 첫 번째 원소를 `k`, 두 번째 원소를 `l`, 세 번째 원소를 `m`으로 했습니다.   
`commands` 배열은 인덱스가 아닌 '몇 번째'에 위치한 원소인지를 나타내기 때문에 인덱스로 변환하기 위하여 1을 감하였습니다.
`temp` 벡터를 만들어 `array`를 `i`부터 `j`까지 자른 후 그를 `countingSort`로 전달합니다.   
Vector의 Iterator(반복자)의 범위는 반개구간을 사용합니다. 즉   
`[첫 번쨰 인자, 두 번째 인자)`입니다. 그렇기에 벡터 `arr`의 모든 원소를 가져오기 위해 `(array.begin() + k, array.begin() + l + 1)`과 같이 작성합니다.   
다시 말해 `array.begin() + l`은 `array`의 `l - 1`번째 원소입니다.   
`l` 번째 원소까지 전달하기 위해 `array.begin() + l + 1`을 합니다.   
총 반복을 `commands`의 행 개수만큼 합니다. 한 행이 하나의 테스트 케이스이므로 결과 벡터에 반복이 끝날 때마다 하나씩 push 해줍니다.

main 함수는 결과를 보기 위해 작성한 것으로 크게 의미는 없습니다.

## 배운 점
정렬할 값의 범위가 제한적일 때 계수 정렬을 사용하면 비교 기반 정렬보다 빠른 시간 안에 정렬을 할 수 있다는 것을 알았습니다.

## 다른 풀이
```cpp
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> solution(vector<int> array, vector<vector<int>> commands) {
    vector<int> answer;
    vector<int> temp;

    for(int i = 0; i < commands.size(); i++) {
        temp = array;
        sort(temp.begin() + commands[i][0] - 1, temp.begin() + commands[i][1]);
        answer.push_back(temp[commands[i][0] - 1 + commands[i][2] - 1]);
    }

    return answer;
}
```